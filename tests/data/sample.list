# file opened: main.asm
  1   0000              ;===========================================================================
  2   0000              ; main.asm
  3   0000              ;===========================================================================
  4   0000
  5   0000                  SLDOPT COMMENT WPMEM, LOGPOINT, ASSERTION
  6   0000
  7   0000              NEX:    equ 0   ;  1=Create nex file, 0=create sna file
  8   0000
  9   0000                  IF NEX == 0
 10   0000                      DEVICE ZXSPECTRUM128
 11   0000                      ;DEVICE ZXSPECTRUM48
 12   0000                  ELSE
 13   0000 ~                    DEVICE ZXSPECTRUMNEXT
 14   0000                  ENDIF
 15   0000
 16   0000                  ORG 0x4000
 17   4000 00 00 00...      defs 0x6000 - $    ; move after screen area
 18   6000 00           screen_top: defb    0   ; WPMEMx
 19   6001
 20   6001
 21   6001              ;===========================================================================
 22   6001              ; Persistent watchpoint.
 23   6001              ; Change WPMEMx (remove the 'x' from WPMEMx) below to activate.
 24   6001              ; If you do so the program will hit a breakpoint when it tries to
 25   6001              ; write to the first byte of the 3rd line.
 26   6001              ; When program breaks in the fill_memory sub routine please hover over hl
 27   6001              ; to see that it contains 0x5804 or COLOR_SCREEN+64.
 28   6001              ;===========================================================================
 29   6001
 30   6001              ; WPMEMx 0x5840, 1, w
 31   6001
 32   6001
 33   6001              ;===========================================================================
 34   6001              ; Include modules
 35   6001              ;===========================================================================
 36   6001                  include "utilities.asm"
# file opened: utilities.asm
  1+  6001              ;===========================================================================
  2+  6001              ; utilities.asm
  3+  6001              ; Submodule for some common routines.
  4+  6001              ;===========================================================================
  5+  6001
  6+  6001              ; Some constants
  7+  6001              PAUSE_TIME:     equ 500   ; 0.5 sec
  8+  6001
  9+  6001
 10+  6001              ; Pauses for a while.
 11+  6001              ; de: wait time, ca. de*0.1ms
 12+  6001              pause:
 13+  6001              ;	ret	; comment this line if you would like to see a pause between drawing of the lines.
 14+  6001
 15+  6001 F5           	push af
 16+  6002 C5           	push bc
 17+  6003
 18+  6003              pause_loop_l2:
 19+  6003 06 1A        	ld b,26
 20+  6005              pause_loop_l1:
 21+  6005 10 FE        	djnz pause_loop_l1 ; 1 cycle should be roughly 100us=0.1ms
 22+  6007
 23+  6007 1B           	dec de
 24+  6008 7A           	ld a,d
 25+  6009 B3           	or e
 26+  600A 20 F7        	jr nz,pause_loop_l2
 27+  600C
 28+  600C C1           	pop bc
 29+  600D F1           	pop af
 30+  600E C9           	ret
 31+  600F
 32+  600F
 33+  600F
 34+  600F
 35+  600F              ;===========================================================================
 36+  600F              ; Writes a color to the border and waits on keypress
 37+  600F              ; of SPACE.
 38+  600F              ; Used for visual debugging.
 39+  600F              ; Changes:
 40+  600F              ;   A
 41+  600F              ;===========================================================================
 42+  600F              	MACRO WAIT_SPACE color?
 43+  600F ~            	ld a,color?
 44+  600F ~            	out (BORDER),a
 45+  600F ~            	; Wait on key press
 46+  600F ~            .not_pressed:
 47+  600F ~            	ld a,HIGH PORT_KEYB_BNMSHIFTSPACE
 48+  600F ~            	in a,(LOW PORT_KEYB_BNMSHIFTSPACE)
 49+  600F ~            	bit 0,a	; SPACE
 50+  600F ~            	jr nz,.not_pressed
 51+  600F ~            	; Wait on key release
 52+  600F ~            .pressed:
 53+  600F ~            	ld a,HIGH PORT_KEYB_BNMSHIFTSPACE
 54+  600F ~            	in a,(LOW PORT_KEYB_BNMSHIFTSPACE)
 55+  600F ~            	bit 0,a	; SPACE
 56+  600F ~            	jr z,.pressed
 57+  600F              	ENDM
 58+  600F
# file closed: utilities.asm
 37   600F                  include "fill.asm"
# file opened: fill.asm
  1+  600F              ;===========================================================================
  2+  600F              ; fill.asm
  3+  600F              ; Submodule with memory fill routines.
  4+  600F              ;===========================================================================
  5+  600F
  6+  600F              ; Some constants
  7+  600F              BCKG_LINE_SIZE:  equ     32
  8+  600F
  9+  600F              ; Colors
 10+  600F              BLACK:          equ 0<<3
 11+  600F              BLUE:           equ 1<<3
 12+  600F              RED:            equ 2<<3
 13+  600F              MAGENTA:        equ 3<<3
 14+  600F              GREEN:          equ 4<<3
 15+  600F              CYAN:           equ 5<<3
 16+  600F              YELLOW:         equ 6<<3
 17+  600F              WHITE:          equ 7<<3
 18+  600F
 19+  600F
 20+  600F              /* Fills a memory area with a certain value.
 21+  600F               a = contains the fill value.
 22+  600F               hl = address to fill
 23+  600F               bc = sigze */
 24+  600F              fill_memory:
 24+  600F              @fill_mem1:
 24+  600F              fill_mem2:
 25+  600F 77               ld (hl),a
 26+  6010 5D               ld e,l
 27+  6011 54               ld d,h
 28+  6012 13               inc de
 29+  6013 0B               dec bc
 30+  6014 ED B0            ldir
 31+  6016 C9               ret
 32+  6017 jp TestSuite_Fill.UT
 33+  6017  call fill_me
 34+  6017              ; Fills a background line with a color.
 35+  6017              ; IN:
 36+  6017              ; a = color
 37+  6017              ; de = points to background screen
 38+  6017              ; OUT:
 39+  6017              ; de = pointing to next line
 40+  6017              fill_bckg_line1:
 41+  6017 01 20 00         ld bc,BCKG_LINE_SIZE
 42+  601A 6B               ld l,e
 43+  601B 62               ld h,d
 44+  601C CD 0F 60         call fill_memory
 45+  601F                  ; check that destination address is still in screen background
 46+  601F 21 FF 5A         ld hl,COLOR_SCREEN+COLOR_SCREEN_SIZE-1
 47+  6022 B7               or a    ; clear carry
 48+  6023 ED 52            sbc hl,de ; compare
 49+  6025 F0               ret p
 50+  6026                  ; ld start address
 51+  6026 11 00 58         ld de,COLOR_SCREEN
 52+  6029 C9               ret
 53+  602A
 54+  602A
 55+  602A              ; Increments the fill_colors_ptr and resets it if necessary.
 56+  602A              inc_fill_colors_ptr:
 57+  602A 2A 3F 60         ld hl,(fill_colors_ptr)
 58+  602D 23               inc hl
 59+  602E 22 3F 60         ld (fill_colors_ptr),hl
 60+  6031
 61+  6031                  ; check if out of range
 62+  6031 01 46 60         ld bc,fill_colors_end
 63+  6034 B7               or a    ; clear carry
 64+  6035 ED 42            sbc hl,bc ; compare
 65+  6037 F8               ret m
 66+  6038
 67+  6038                  ; reset
 68+  6038 21 41 60         ld hl,fill_colors
 69+  603B 22 3F 60         ld (fill_colors_ptr),hl
 70+  603E C9               ret
 71+  603F
 72+  603F              ; WPMEM 603Fh
 73+  603F              ; Pointer to fill colors.
 74+  603F 00 00        fill_colors_ptr:    defw 0  ; WPMExM
 75+  6041
 76+  6041              ; Contains the colors for the lines. Each entry represnts the color for one line.
 77+  6041              fill_colors:
 78+  6041 10 30 08 20      defb RED, YELLOW, BLUE, GREEN, MAGENTA
 78+  6045 18
 79+  6046              fill_colors_end:
 80+  6046 00               defb 0  ; WPMEM
 81+  6047
# file closed: fill.asm
 38   6047                  include "clearscreen.asm"
# file opened: clearscreen.asm
  1+  6047              ;===========================================================================
  2+  6047              ; clearscreen.asm
  3+  6047              ; Submodule to clear the entire screen.
  4+  6047              ;===========================================================================
  5+  6047
  6+  6047              ; Some constants
  7+  6047              SCREEN:         equ 0x4000
  8+  6047              SCREEN_SIZE:    equ 0x1800
  9+  6047
 10+  6047              COLOR_SCREEN:       equ 0x5800
 11+  6047              ;COLOR_SCREEN:       equ 0xD800  ; For bank 7
 12+  6047              COLOR_SCREEN_SIZE:  equ 0x0300
 13+  6047
 14+  6047
 15+  6047              ; Clears the screen
 16+  6047              clear_screen:
 17+  6047 AF               xor a
 18+  6048 01 00 18         ld bc,SCREEN_SIZE
 19+  604B 21 00 40         ld hl,SCREEN
 20+  604E CD 0F 60         call fill_memory
 21+  6051 C9               ret
 22+  6052
 23+  6052
 24+  6052              ; Clears the background
 25+  6052              clear_backg:
 26+  6052 AF               xor a
 27+  6053 CD 57 60         call fill_backg
 28+  6056 C9               ret
 29+  6057
 30+  6057
 31+  6057              ; Fills the background with fore and background color.
 32+  6057              ; a contains the fill color.
 33+  6057              fill_backg:
 34+  6057 01 00 03         ld bc,COLOR_SCREEN_SIZE
 35+  605A 21 00 58         ld hl,COLOR_SCREEN
 36+  605D CD 0F 60         call fill_memory
 37+  6060 C9               ret
 38+  6061
 39+  6061
 40+  6061
# file closed: clearscreen.asm
 39   6061
 40   6061                  ; Normally you would assemble the unit tests in a separate target
 41   6061                  ; in the makefile.
 42   6061                  ; As this is a very short program and for simplicity the
 43   6061                  ; unit tests and the main program are assembled in the same binary.
 44   6061                  include "unit_tests.asm"
# file opened: unit_tests.asm
  1+  6061              ;========================================================
  2+  6061              ; unit_tests.asm
  3+  6061              ;
  4+  6061              ; Collects and executes all unit tests.
  5+  6061              ;========================================================
  6+  6061
  7+  6061                  include "unit_tests.inc"
# file opened: unit_tests.inc
  1++ 6061              ;--------------------------------------------------------
  2++ 6061              ; unit_tests.inc
  3++ 6061              ;
  4++ 6061              ; Contains all macros used for unit testing.
  5++ 6061              ; For sjasmplus.
  6++ 6061              ;--------------------------------------------------------
  7++ 6061
  8++ 6061                  ; -----------------------------------------------------------
  9++ 6061                  ; Code for sjasmplus
 10++ 6061
 11++ 6061                  MACRO UNITTEST_INITIALIZE
 12++ 6061 ~
 13++ 6061 ~                ; Called to call each unit test.
 14++ 6061 ~            @UNITTEST_TEST_WRAPPER:
 15++ 6061 ~                    di
 16++ 6061 ~                    ld sp,UNITTEST_STACK
 17++ 6061 ~            @UNITTEST_CALL_ADDR:
 18++ 6061 ~                    call 0x0000 ; Will be changed by the z80 unit tests.
 19++ 6061 ~                    nop
 20++ 6061 ~
 21++ 6061 ~            @UNITTEST_TEST_READY_SUCCESS:
 22++ 6061 ~                    jr UNITTEST_TEST_READY_SUCCESS	; A breakpoint will be set here.
 23++ 6061 ~
 24++ 6061 ~            ; Stack
 25++ 6061 ~            @UNITTEST_STACK_BOTTOM:
 26++ 6061 ~                    defw 0
 27++ 6061 ~                    defs 2*50	; Stack depth of 50 should be enough
 28++ 6061 ~            @UNITTEST_STACK:
 29++ 6061 ~                    defw 0
 30++ 6061 ~
 31++ 6061 ~                ; The unit test initialization. Provided by the user.
 32++ 6061 ~            @UNITTEST_START:
 33++ 6061 ~                    ; Disable interrupts
 34++ 6061 ~                    di
 35++ 6061 ~                    ; Flow through.
 36++ 6061 ~                    ; Directly after the UNITTEST_INITIALIZE macro the user
 37++ 6061 ~                    ; should put his test initialization code.
 38++ 6061 ~                    ; Note: the stack pointer does not need to be set up.
 39++ 6061 ~
 40++ 6061                  ENDM
 41++ 6061
 42++ 6061
 43++ 6061                  ; Macro that must be used at the end of the test case (instead of a ret).
 44++ 6061                  MACRO TC_END
 45++ 6061 ~                    jp UNITTEST_TEST_READY_SUCCESS
 46++ 6061                  ENDM
 47++ 6061
 48++ 6061
 49++ 6061                  ; Tests a memory address for a specific byte value.
 50++ 6061                  MACRO TEST_MEMORY_BYTE addr?, value?
 51++ 6061 ~                    push hl
 52++ 6061 ~                    ld hl,addr?
 53++ 6061 ~                    ld l,(hl)
 54++ 6061 ~                    ld h,value?
 55++ 6061 ~                    nop ; ASSERTION L == H
 56++ 6061 ~                    pop hl
 57++ 6061                  ENDM
 58++ 6061
 59++ 6061                  ; Tests a memory address for a specific word value.
 60++ 6061                  ; If the test fails the '(addr)' can be found in DE.
 61++ 6061                  MACRO TEST_MEMORY_WORD addr?, value?
 62++ 6061 ~                    push hl, de
 63++ 6061 ~                    ld hl,addr?
 64++ 6061 ~                    ld e,(hl)
 65++ 6061 ~                    inc hl
 66++ 6061 ~                    ld d,(hl)
 67++ 6061 ~                    ld hl,value?
 68++ 6061 ~                    nop ; ASSERTION DE == HL
 69++ 6061 ~                    pop de, hl
 70++ 6061                  ENDM
 71++ 6061
 72++ 6061                  ; Creates a failure when reached.
 73++ 6061                  MACRO TEST_FAIL
 74++ 6061 ~                    nop ; ASSERTION false
 75++ 6061                  ENDM
 76++ 6061
 77++ 6061
 78++ 6061
 79++ 6061                  ; Compares 2 memory areas containing null terminated strings.
 80++ 6061                  ; addr1 = the first string
 81++ 6061                  ; addr2 = the second string
 82++ 6061                  MACRO TEST_STRING_PTR addr1?, addr2?
 83++ 6061 ~                    push af
 84++ 6061 ~                    push hl
 85++ 6061 ~                    push de
 86++ 6061 ~                    ld de,addr2?
 87++ 6061 ~                    ld hl,addr1?
 88++ 6061 ~            .loop:
 89++ 6061 ~                    ld a,(de)
 90++ 6061 ~                    ; Check for null termination
 91++ 6061 ~                    cp (hl)
 92++ 6061 ~                    jr nz,.not_equal
 93++ 6061 ~                    or a
 94++ 6061 ~                    jr z,.null_found
 95++ 6061 ~                    inc de
 96++ 6061 ~                    inc hl
 97++ 6061 ~                    jr .loop
 98++ 6061 ~
 99++ 6061 ~            .not_equal:
100++ 6061 ~                    ; Strings are not equal
101++ 6061 ~                    pop de
102++ 6061 ~                    pop hl
103++ 6061 ~                    pop af
104++ 6061 ~                    nop ; ASSERTION false
105++ 6061 ~                    jr .end
106++ 6061 ~
107++ 6061 ~            .null_found:
108++ 6061 ~                    pop de
109++ 6061 ~                    pop hl
110++ 6061 ~                    pop af
111++ 6061 ~            .end:
112++ 6061                  ENDM
113++ 6061
114++ 6061
115++ 6061                  ; Tests a memory address for a specific string.
116++ 6061                  ; addr = the tested string
117++ 6061                  ; string = the compared string, e.g. "STRING"
118++ 6061                  ; term0 = If 0 it is also tested that the string (addr) is null terminated
119++ 6061                  MACRO TEST_STRING addr?, string?, term0?
120++ 6061 ~                    push af
121++ 6061 ~                    push hl
122++ 6061 ~                    push de
123++ 6061 ~                    ld de,.comp_string
124++ 6061 ~                    ld hl,addr?
125++ 6061 ~            .loop:
126++ 6061 ~                    ld a,(de)
127++ 6061 ~                    ; Check for null termination
128++ 6061 ~                    or a
129++ 6061 ~                    jr z,.null_found
130++ 6061 ~                    cp (hl)
131++ 6061 ~                    inc de
132++ 6061 ~                    inc hl
133++ 6061 ~                    jr z,.loop
134++ 6061 ~
135++ 6061 ~            .not_equal:
136++ 6061 ~                    ; Strings are not equal
137++ 6061 ~                    pop de
138++ 6061 ~                    pop hl
139++ 6061 ~                    pop af
140++ 6061 ~                    nop ; ASSERTION false
141++ 6061 ~                    jr .end
142++ 6061 ~
143++ 6061 ~            .comp_string:
144++ 6061 ~                    defb string?, 0
145++ 6061 ~
146++ 6061 ~            .null_found:
147++ 6061 ~                    ; We are at the end of the compare string.
148++ 6061 ~                    ; Check if null termination should be compared with the tested string.
149++ 6061 ~                  IF term0? == 0
150++ 6061 ~                    cp (hl)
151++ 6061 ~                    jr nz,.not_equal
152++ 6061 ~                  ENDIF
153++ 6061 ~
154++ 6061 ~                    pop de
155++ 6061 ~                    pop hl
156++ 6061 ~                    pop af
157++ 6061 ~            .end:
158++ 6061                  ENDM
159++ 6061
160++ 6061
161++ 6061                  ; Tests a memory area on equality.
162++ 6061                  ; addr1 = the tested memory area
163++ 6061                  ; addr2 = the memory area to compare to
164++ 6061                  ; count = the number of elements to compare
165++ 6061                  MACRO TEST_MEM_CMP addr1?, addr2?, count?
166++ 6061 ~                    push af
167++ 6061 ~                    push hl
168++ 6061 ~                    push de
169++ 6061 ~                    push bc
170++ 6061 ~                    ld de,addr2?
171++ 6061 ~                    ld hl,addr1?
172++ 6061 ~                    ld bc,count?
173++ 6061 ~            .loop:
174++ 6061 ~                    ld a,(de)
175++ 6061 ~                    ; Compare
176++ 6061 ~                    cpi      ; cp (hl++); dec bc
177++ 6061 ~                    jr nz,.not_equal
178++ 6061 ~                    inc de
179++ 6061 ~                    jp pe,.loop
180++ 6061 ~
181++ 6061 ~                    ; Memory is equal
182++ 6061 ~                    pop bc
183++ 6061 ~                    pop de
184++ 6061 ~                    pop hl
185++ 6061 ~                    pop af
186++ 6061 ~                    jr .end
187++ 6061 ~
188++ 6061 ~            .not_equal:
189++ 6061 ~                    ; Memory areas are not equal
190++ 6061 ~                    pop bc
191++ 6061 ~                    pop de
192++ 6061 ~                    pop hl
193++ 6061 ~                    pop af
194++ 6061 ~                    nop ; ASSERTION false
195++ 6061 ~                    jr .end
196++ 6061 ~            .end:
197++ 6061                  ENDM
198++ 6061
199++ 6061                  ; Initializes the registers with default values.
200++ 6061                  ; Use before the tested function is called.
201++ 6061                  ; After the call the TEST_UNCHANGED_XX tests can be used
202++ 6061                  ; to check if the register was changed.
203++ 6061                  MACRO DEFAULT_REGS
204++ 6061 ~                    ld a,0xAA
205++ 6061 ~                    ld bc,0xBBCC
206++ 6061 ~                    ld de,0xDDEE
207++ 6061 ~                    ld hl,0x8899
208++ 6061                  ENDM
209++ 6061
210++ 6061                  MACRO TEST_UNCHANGED_BC
211++ 6061 ~                    nop ; ASSERTION BC == 0xBBCC
212++ 6061                  ENDM
213++ 6061
214++ 6061                  MACRO TEST_UNCHANGED_DE
215++ 6061 ~                    nop ; ASSERTION DE == 0xDDEE
216++ 6061                  ENDM
217++ 6061
218++ 6061                  MACRO TEST_UNCHANGED_HL
219++ 6061 ~                    nop ; ASSERTION HL == 0x8899
220++ 6061                  ENDM
221++ 6061
222++ 6061                  MACRO TEST_UNCHANGED_BC_DE
223++ 6061 ~                    TEST_UNCHANGED_BC
224++ 6061 ~                    TEST_UNCHANGED_DE
225++ 6061                  ENDM
226++ 6061
227++ 6061                  MACRO TEST_UNCHANGED_BC_DE_HL
228++ 6061 ~                    TEST_UNCHANGED_BC_DE
229++ 6061 ~                    TEST_UNCHANGED_HL
230++ 6061                  ENDM
231++ 6061
232++ 6061                  MACRO TEST_UNCHANGED_A
233++ 6061 ~                    nop ; TEST ASSERTION A == 0xAA
234++ 6061                  ENDM
235++ 6061
236++ 6061                  MACRO TEST_UNCHANGED_B
237++ 6061 ~                    nop ; TEST ASSERTION B == 0xBB
238++ 6061                  ENDM
239++ 6061
240++ 6061                  MACRO TEST_UNCHANGED_C
241++ 6061 ~                    nop ; TEST ASSERTION C == 0xCC
242++ 6061                  ENDM
243++ 6061
244++ 6061                  MACRO TEST_UNCHANGED_D
245++ 6061 ~                    nop ; TEST ASSERTION D == 0xDD
246++ 6061                  ENDM
247++ 6061
248++ 6061                  MACRO TEST_UNCHANGED_E
249++ 6061 ~                    nop ; TEST ASSERTION E == 0xEE
250++ 6061                  ENDM
251++ 6061
252++ 6061                  MACRO TEST_UNCHANGED_H
253++ 6061 ~                    nop ; TEST ASSERTION H == 0x88
254++ 6061                  ENDM
255++ 6061
256++ 6061                  MACRO TEST_UNCHANGED_L
257++ 6061 ~                    nop ; TEST ASSERTION L == 0x99
258++ 6061                  ENDM
259++ 6061
260++ 6061
261++ 6061                  ; Macro to test flags for Z.
262++ 6061                  ; Testcase fails for NZ.
263++ 6061                  MACRO TEST_FLAG_Z
264++ 6061 ~                    nop ; TEST ASSERTION F & 0x40
265++ 6061                  ENDM
266++ 6061
267++ 6061
268++ 6061                  ; Macro to test flags for NZ.
269++ 6061                  ; Testcase fails for Z.
270++ 6061                  MACRO TEST_FLAG_NZ
271++ 6061 ~                    nop ; TEST ASSERTION (F & 0x40) == 0
272++ 6061                  ENDM
273++ 6061
274++ 6061
275++ 6061                  ; This macro uses all registers, also the shadow registers.
276++ 6061                  MACRO USE_ALL_REGS
277++ 6061 ~                    ld a,0xCD
278++ 6061 ~                    ld bc,0xBBCC
279++ 6061 ~                    ld de,0xDDEE
280++ 6061 ~                    ld hl,0xFF11
281++ 6061 ~                    ld ix,0x7788
282++ 6061 ~                    ld iy,0x99AA
283++ 6061 ~                    exx
284++ 6061 ~                    ld a,0xDC
285++ 6061 ~                    ld bc,0x1122
286++ 6061 ~                    ld de,0x3344
287++ 6061 ~                    ld hl,0x5566
288++ 6061 ~                    exx
289++ 6061                  ENDM
290++ 6061
# file closed: unit_tests.inc
  8+  6061
  9+  6061
 10+  6061              ; Initialization routine called before all unit tests are
 11+  6061              ; started.
 12+  6061                  UNITTEST_INITIALIZE
 12+  6061             >
 12+  6061             >    ; Called to call each unit test.
 12+  6061             >@UNITTEST_TEST_WRAPPER:
 12+  6061 F3          >        di
 12+  6062 31 D1 60    >        ld sp,UNITTEST_STACK
 12+  6065             >@UNITTEST_CALL_ADDR:
 12+  6065 CD 00 00    >        call 0x0000 ; Will be changed by the z80 unit tests.
 12+  6068 00          >        nop
 12+  6069             >
 12+  6069             >@UNITTEST_TEST_READY_SUCCESS:
 12+  6069 18 FE       >        jr UNITTEST_TEST_READY_SUCCESS	; A breakpoint will be set here.
 12+  606B             >
 12+  606B             >; Stack
 12+  606B             >@UNITTEST_STACK_BOTTOM:
 12+  606B 00 00       >        defw 0
 12+  606D 00 00 00... >        defs 2*50	; Stack depth of 50 should be enough
 12+  60D1             >@UNITTEST_STACK:
 12+  60D1 00 00       >        defw 0
 12+  60D3             >
 12+  60D3             >    ; The unit test initialization. Provided by the user.
 12+  60D3             >@UNITTEST_START:
 12+  60D3             >        ; Disable interrupts
 12+  60D3 F3          >        di
 12+  60D4             >        ; Flow through.
 12+  60D4             >        ; Directly after the UNITTEST_INITIALIZE macro the user
 12+  60D4             >        ; should put his test initialization code.
 12+  60D4             >        ; Note: the stack pointer does not need to be set up.
 12+  60D4             >
 13+  60D4                  ; Do your initialization here ...
 14+  60D4                  ; ...
 15+  60D4                  ; ...
 16+  60D4                  ; For this simple example we don't need any special initialization.
 17+  60D4                  ; So we simply return.
 18+  60D4                  ; Please note: the stack pointer does not need to be setup explicitly
 19+  60D4                  ; for the unit tests.
 20+  60D4 C9               ret
 21+  60D5
 22+  60D5
 23+  60D5                  MODULE TestSuite_ClearScreen
 24+  60D5
 25+  60D5              ; A unit testcase needs to start with "UT_" (upper case letters).
 26+  60D5              ; DeZog will collect all these labels and offer them for execution.
 27+  60D5
 28+  60D5              ; Tests that the screen is cleared/filled with 0's.
 29+  60D5              UT_clear_screen:
 30+  60D5                  ; Write some bytes to the screen area
 31+  60D5 3E FF            ld a,0xFF
 32+  60D7 32 00 40         ld (SCREEN),a
 33+  60DA 32 00 4C         ld (SCREEN+SCREEN_SIZE/2),a
 34+  60DD 32 FF 57         ld (SCREEN+SCREEN_SIZE-1),a
 35+  60E0 32 00 58         ld (SCREEN+SCREEN_SIZE),a
 36+  60E3
 37+  60E3                  ; Now clear the screen
 38+  60E3 CD 47 60         call clear_screen
 39+  60E6
 40+  60E6                  ; Test that all values inside the screen area are cleared
 41+  60E6                  TEST_MEMORY_BYTE SCREEN, 0
 41+  60E6 E5          >        push hl
 41+  60E7 21 00 40    >        ld hl,SCREEN
 41+  60EA 6E          >        ld l,(hl)
 41+  60EB 26 00       >        ld h,0
 41+  60ED 00          >        nop ; ASSERTION L == H
 41+  60EE E1          >        pop hl
 42+  60EF                  TEST_MEMORY_BYTE SCREEN+SCREEN_SIZE/2, 0
 42+  60EF E5          >        push hl
 42+  60F0 21 00 4C    >        ld hl,SCREEN+SCREEN_SIZE/2
 42+  60F3 6E          >        ld l,(hl)
 42+  60F4 26 00       >        ld h,0
 42+  60F6 00          >        nop ; ASSERTION L == H
 42+  60F7 E1          >        pop hl
 43+  60F8                  TEST_MEMORY_BYTE SCREEN+SCREEN_SIZE-1, 0
 43+  60F8 E5          >        push hl
 43+  60F9 21 FF 57    >        ld hl,SCREEN+SCREEN_SIZE-1
 43+  60FC 6E          >        ld l,(hl)
 43+  60FD 26 00       >        ld h,0
 43+  60FF 00          >        nop ; ASSERTION L == H
 43+  6100 E1          >        pop hl
 44+  6101
 45+  6101                  TEST_MEMORY_BYTE SCREEN+SCREEN_SIZE, 0xFF
 45+  6101 E5          >        push hl
 45+  6102 21 00 58    >        ld hl,SCREEN+SCREEN_SIZE
 45+  6105 6E          >        ld l,(hl)
 45+  6106 26 FF       >        ld h,0xFF
 45+  6108 00          >        nop ; ASSERTION L == H
 45+  6109 E1          >        pop hl
 46+  610A 00               nop
 47+  610B               TC_END
 47+  610B C3 69 60    >        jp UNITTEST_TEST_READY_SUCCESS
 48+  610E
 49+  610E
 50+  610E              ; Tests filling the background.
 51+  610E              UT_fill_backg:
 52+  610E                  ; Write some bytes to the screen area
 53+  610E 3E FF            ld a,0xFF
 54+  6110 32 00 58         ld (COLOR_SCREEN),a
 55+  6113 32 80 59         ld (COLOR_SCREEN+COLOR_SCREEN_SIZE/2),a
 56+  6116 32 FF 5A         ld (COLOR_SCREEN+COLOR_SCREEN_SIZE-1),a
 57+  6119 32 00 5B         ld (COLOR_SCREEN+COLOR_SCREEN_SIZE),a
 58+  611C
 59+  611C                  ; Now fill the background with 128
 60+  611C 3E 80            ld a,128
 61+  611E CD 57 60         call fill_backg
 62+  6121
 63+  6121                  ; Test that all values inside the screen area are cleared
 64+  6121                  TEST_MEMORY_BYTE COLOR_SCREEN, 128
 64+  6121 E5          >        push hl
 64+  6122 21 00 58    >        ld hl,COLOR_SCREEN
 64+  6125 6E          >        ld l,(hl)
 64+  6126 26 80       >        ld h,128
 64+  6128 00          >        nop ; ASSERTION L == H
 64+  6129 E1          >        pop hl
 65+  612A                  TEST_MEMORY_BYTE COLOR_SCREEN+COLOR_SCREEN_SIZE/2, 128
 65+  612A E5          >        push hl
 65+  612B 21 80 59    >        ld hl,COLOR_SCREEN+COLOR_SCREEN_SIZE/2
 65+  612E 6E          >        ld l,(hl)
 65+  612F 26 80       >        ld h,128
 65+  6131 00          >        nop ; ASSERTION L == H
 65+  6132 E1          >        pop hl
 66+  6133                  TEST_MEMORY_BYTE COLOR_SCREEN+COLOR_SCREEN_SIZE-1, 128
 66+  6133 E5          >        push hl
 66+  6134 21 FF 5A    >        ld hl,COLOR_SCREEN+COLOR_SCREEN_SIZE-1
 66+  6137 6E          >        ld l,(hl)
 66+  6138 26 80       >        ld h,128
 66+  613A 00          >        nop ; ASSERTION L == H
 66+  613B E1          >        pop hl
 67+  613C
 68+  613C                  TEST_MEMORY_BYTE COLOR_SCREEN+COLOR_SCREEN_SIZE, 0xFF
 68+  613C E5          >        push hl
 68+  613D 21 00 5B    >        ld hl,COLOR_SCREEN+COLOR_SCREEN_SIZE
 68+  6140 6E          >        ld l,(hl)
 68+  6141 26 FF       >        ld h,0xFF
 68+  6143 00          >        nop ; ASSERTION L == H
 68+  6144 E1          >        pop hl
 69+  6145               TC_END
 69+  6145 C3 69 60    >        jp UNITTEST_TEST_READY_SUCCESS
 70+  6148
 71+  6148
 72+  6148              ; Tests clearing the background.
 73+  6148              UT_clear_backg:
 74+  6148                  ; Write some bytes to the screen area
 75+  6148 3E FF            ld a,0xFF
 76+  614A 32 00 58         ld (COLOR_SCREEN),a
 77+  614D 32 80 59         ld (COLOR_SCREEN+COLOR_SCREEN_SIZE/2),a
 78+  6150 32 FF 5A         ld (COLOR_SCREEN+COLOR_SCREEN_SIZE-1),a
 79+  6153 32 00 5B         ld (COLOR_SCREEN+COLOR_SCREEN_SIZE),a
 80+  6156
 81+  6156                  ; Now clear the background
 82+  6156 CD 52 60         call clear_backg
 83+  6159
 84+  6159                  ; Test that all values inside the screen area are cleared
 85+  6159                  TEST_MEMORY_BYTE COLOR_SCREEN, 0
 85+  6159 E5          >        push hl
 85+  615A 21 00 58    >        ld hl,COLOR_SCREEN
 85+  615D 6E          >        ld l,(hl)
 85+  615E 26 00       >        ld h,0
 85+  6160 00          >        nop ; ASSERTION L == H
 85+  6161 E1          >        pop hl
 86+  6162                  TEST_MEMORY_BYTE COLOR_SCREEN+COLOR_SCREEN_SIZE/2, 0
 86+  6162 E5          >        push hl
 86+  6163 21 80 59    >        ld hl,COLOR_SCREEN+COLOR_SCREEN_SIZE/2
 86+  6166 6E          >        ld l,(hl)
 86+  6167 26 00       >        ld h,0
 86+  6169 00          >        nop ; ASSERTION L == H
 86+  616A E1          >        pop hl
 87+  616B                  TEST_MEMORY_BYTE COLOR_SCREEN+COLOR_SCREEN_SIZE-1, 0
 87+  616B E5          >        push hl
 87+  616C 21 FF 5A    >        ld hl,COLOR_SCREEN+COLOR_SCREEN_SIZE-1
 87+  616F 6E          >        ld l,(hl)
 87+  6170 26 00       >        ld h,0
 87+  6172 00          >        nop ; ASSERTION L == H
 87+  6173 E1          >        pop hl
 88+  6174
 89+  6174                  TEST_MEMORY_BYTE COLOR_SCREEN+COLOR_SCREEN_SIZE, 0xFF
 89+  6174 E5          >        push hl
 89+  6175 21 00 5B    >        ld hl,COLOR_SCREEN+COLOR_SCREEN_SIZE
 89+  6178 6E          >        ld l,(hl)
 89+  6179 26 FF       >        ld h,0xFF
 89+  617B 00          >        nop ; ASSERTION L == H
 89+  617C E1          >        pop hl
 90+  617D               TC_END
 90+  617D C3 69 60    >        jp UNITTEST_TEST_READY_SUCCESS
 91+  6180
 92+  6180                  ENDMODULE
 93+  6180
 94+  6180
 95+  6180
 96+  6180                  MODULE TestSuite_Fill
 97+  6180
 98+  6180              ; Tests filling a memory area
 99+  6180              UT_fill_memory:
100+  6180                  ; Write some bytes
101+  6180 3E FF            ld a,0xFF
102+  6182 32 CC 61         ld (fill_memory_data-1),a
103+  6185 32 CD 61         ld (fill_memory_data),a
104+  6188 32 D2 61         ld (fill_memory_data+FILL_MEMORY_SIZE/2),a
105+  618B 32 D6 61         ld (fill_memory_data+FILL_MEMORY_SIZE-1),a
106+  618E 32 D7 61         ld (fill_memory_data+FILL_MEMORY_SIZE),a
107+  6191
108+  6191                  ; Now fill the memory area
109+  6191 3E 16            ld a,22
110+  6193 21 CD 61         ld hl,fill_memory_data
111+  6196 01 0A 00         ld bc,FILL_MEMORY_SIZE
112+  6199 CD 0F 60         call fill_memory
113+  619C
114+  619C                  ; Test that all values inside the screen area are cleared
115+  619C                  TEST_MEMORY_BYTE fill_memory_data-1, 0xFF
115+  619C E5          >        push hl
115+  619D 21 CC 61    >        ld hl,fill_memory_data-1
115+  61A0 6E          >        ld l,(hl)
115+  61A1 26 FF       >        ld h,0xFF
115+  61A3 00          >        nop ; ASSERTION L == H
115+  61A4 E1          >        pop hl
116+  61A5                  TEST_MEMORY_BYTE fill_memory_data, 22
116+  61A5 E5          >        push hl
116+  61A6 21 CD 61    >        ld hl,fill_memory_data
116+  61A9 6E          >        ld l,(hl)
116+  61AA 26 16       >        ld h,22
116+  61AC 00          >        nop ; ASSERTION L == H
116+  61AD E1          >        pop hl
117+  61AE                  TEST_MEMORY_BYTE fill_memory_data+FILL_MEMORY_SIZE/2, 22
117+  61AE E5          >        push hl
117+  61AF 21 D2 61    >        ld hl,fill_memory_data+FILL_MEMORY_SIZE/2
117+  61B2 6E          >        ld l,(hl)
117+  61B3 26 16       >        ld h,22
117+  61B5 00          >        nop ; ASSERTION L == H
117+  61B6 E1          >        pop hl
118+  61B7                  TEST_MEMORY_BYTE fill_memory_data+FILL_MEMORY_SIZE-1, 22
118+  61B7 E5          >        push hl
118+  61B8 21 D6 61    >        ld hl,fill_memory_data+FILL_MEMORY_SIZE-1
118+  61BB 6E          >        ld l,(hl)
118+  61BC 26 16       >        ld h,22
118+  61BE 00          >        nop ; ASSERTION L == H
118+  61BF E1          >        pop hl
119+  61C0
120+  61C0                  TEST_MEMORY_BYTE fill_memory_data+FILL_MEMORY_SIZE, 0xFF
120+  61C0 E5          >        push hl
120+  61C1 21 D7 61    >        ld hl,fill_memory_data+FILL_MEMORY_SIZE
120+  61C4 6E          >        ld l,(hl)
120+  61C5 26 FF       >        ld h,0xFF
120+  61C7 00          >        nop ; ASSERTION L == H
120+  61C8 E1          >        pop hl
121+  61C9               TC_END
121+  61C9 C3 69 60    >        jp UNITTEST_TEST_READY_SUCCESS
122+  61CC
123+  61CC
124+  61CC              FILL_MEMORY_SIZE:   equ 10
125+  61CC 00               defb 0
126+  61CD              fill_memory_data:
127+  61CD 00 00 00...      defs 10
128+  61D7 00               defb 0
129+  61D8
130+  61D8
131+  61D8              ; Tests filling a line in the background color screen.
132+  61D8              UT_fill_bckg_line_normal:
133+  61D8                  ; Initialize background
134+  61D8 CD 52 60         call clear_backg
135+  61DB
136+  61DB                  ; Fill line with color
137+  61DB 3E 18            ld a,MAGENTA
138+  61DD 11 00 58         ld de,COLOR_SCREEN
139+  61E0 CD 17 60         call fill_bckg_line1
140+  61E3
141+  61E3                  ; Test that line is filled
142+  61E3                  TEST_MEMORY_BYTE COLOR_SCREEN, MAGENTA
142+  61E3 E5          >        push hl
142+  61E4 21 00 58    >        ld hl,COLOR_SCREEN
142+  61E7 6E          >        ld l,(hl)
142+  61E8 26 18       >        ld h,MAGENTA
142+  61EA 00          >        nop ; ASSERTION L == H
142+  61EB E1          >        pop hl
143+  61EC                  TEST_MEMORY_BYTE COLOR_SCREEN+16, MAGENTA
143+  61EC E5          >        push hl
143+  61ED 21 10 58    >        ld hl,COLOR_SCREEN+16
143+  61F0 6E          >        ld l,(hl)
143+  61F1 26 18       >        ld h,MAGENTA
143+  61F3 00          >        nop ; ASSERTION L == H
143+  61F4 E1          >        pop hl
144+  61F5                  TEST_MEMORY_BYTE COLOR_SCREEN+31, MAGENTA
144+  61F5 E5          >        push hl
144+  61F6 21 1F 58    >        ld hl,COLOR_SCREEN+31
144+  61F9 6E          >        ld l,(hl)
144+  61FA 26 18       >        ld h,MAGENTA
144+  61FC 00          >        nop ; ASSERTION L == H
144+  61FD E1          >        pop hl
145+  61FE                  TEST_MEMORY_BYTE COLOR_SCREEN+32, 0
145+  61FE E5          >        push hl
145+  61FF 21 20 58    >        ld hl,COLOR_SCREEN+32
145+  6202 6E          >        ld l,(hl)
145+  6203 26 00       >        ld h,0
145+  6205 00          >        nop ; ASSERTION L == H
145+  6206 E1          >        pop hl
146+  6207
147+  6207                  ; Test that de points to the next line
148+  6207 00               nop ; ASSERTION DE == COLOR_SCREEN+32
149+  6208               TC_END
149+  6208 C3 69 60    >        jp UNITTEST_TEST_READY_SUCCESS
150+  620B
151+  620B              ; Test wrap around.
152+  620B              UT_fill_bckg_line_wrap_around:
153+  620B                  ; Initialize background
154+  620B CD 52 60         call clear_backg
155+  620E
156+  620E                  ; Fill line with color
157+  620E 3E 18            ld a,MAGENTA
158+  6210 11 E0 5A         ld de,COLOR_SCREEN+23*32
159+  6213 CD 17 60         call fill_bckg_line1
160+  6216
161+  6216                  ; Test that line is filled
162+  6216                  TEST_MEMORY_BYTE COLOR_SCREEN+23*32, MAGENTA
162+  6216 E5          >        push hl
162+  6217 21 E0 5A    >        ld hl,COLOR_SCREEN+23*32
162+  621A 6E          >        ld l,(hl)
162+  621B 26 18       >        ld h,MAGENTA
162+  621D 00          >        nop ; ASSERTION L == H
162+  621E E1          >        pop hl
163+  621F                  TEST_MEMORY_BYTE COLOR_SCREEN+23*32+16, MAGENTA
163+  621F E5          >        push hl
163+  6220 21 F0 5A    >        ld hl,COLOR_SCREEN+23*32+16
163+  6223 6E          >        ld l,(hl)
163+  6224 26 18       >        ld h,MAGENTA
163+  6226 00          >        nop ; ASSERTION L == H
163+  6227 E1          >        pop hl
164+  6228                  TEST_MEMORY_BYTE COLOR_SCREEN+23*32+31, MAGENTA
164+  6228 E5          >        push hl
164+  6229 21 FF 5A    >        ld hl,COLOR_SCREEN+23*32+31
164+  622C 6E          >        ld l,(hl)
164+  622D 26 18       >        ld h,MAGENTA
164+  622F 00          >        nop ; ASSERTION L == H
164+  6230 E1          >        pop hl
165+  6231                  TEST_MEMORY_BYTE COLOR_SCREEN+23*32-1, 0
165+  6231 E5          >        push hl
165+  6232 21 DF 5A    >        ld hl,COLOR_SCREEN+23*32-1
165+  6235 6E          >        ld l,(hl)
165+  6236 26 00       >        ld h,0
165+  6238 00          >        nop ; ASSERTION L == H
165+  6239 E1          >        pop hl
166+  623A
167+  623A                  ; Test that de points to the first line (wrap around)
168+  623A 00               nop ; ASSERTION DE == COLOR_SCREEN
169+  623B               TC_END
169+  623B C3 69 60    >        jp UNITTEST_TEST_READY_SUCCESS
170+  623E
171+  623E
172+  623E              ; Test wrap around.
173+  623E              UT_fill_colors_ptr:
174+  623E                  ; Start value
175+  623E 21 41 60         ld hl,fill_colors
176+  6241 22 3F 60         ld (fill_colors_ptr),hl
177+  6244
178+  6244                  ; Test increment
179+  6244 CD 2A 60         call inc_fill_colors_ptr
180+  6247                  ; Test that pointer is moved to next line
181+  6247                  TEST_MEMORY_WORD fill_colors_ptr, fill_colors+1
181+  6247 E5 D5       >        push hl, de
181+  6249 21 3F 60    >        ld hl,fill_colors_ptr
181+  624C 5E          >        ld e,(hl)
181+  624D 23          >        inc hl
181+  624E 56          >        ld d,(hl)
181+  624F 21 42 60    >        ld hl,fill_colors+1
181+  6252 00          >        nop ; ASSERTION DE == HL
181+  6253 D1 E1       >        pop de, hl
182+  6255
183+  6255                  ; Test increment
184+  6255 CD 2A 60         call inc_fill_colors_ptr
185+  6258                  ; Test that pointer is moved to next line
186+  6258                  TEST_MEMORY_WORD fill_colors_ptr, fill_colors+2
186+  6258 E5 D5       >        push hl, de
186+  625A 21 3F 60    >        ld hl,fill_colors_ptr
186+  625D 5E          >        ld e,(hl)
186+  625E 23          >        inc hl
186+  625F 56          >        ld d,(hl)
186+  6260 21 43 60    >        ld hl,fill_colors+2
186+  6263 00          >        nop ; ASSERTION DE == HL
186+  6264 D1 E1       >        pop de, hl
187+  6266
188+  6266                  ; Last value
189+  6266 21 45 60         ld hl,fill_colors_end-1
190+  6269 22 3F 60         ld (fill_colors_ptr),hl
191+  626C
192+  626C                  ; Test increment
193+  626C CD 2A 60         call inc_fill_colors_ptr
194+  626F                  ; Test that pointer wraps around and points to first line
195+  626F                  TEST_MEMORY_WORD fill_colors_ptr, fill_colors
195+  626F E5 D5       >        push hl, de
195+  6271 21 3F 60    >        ld hl,fill_colors_ptr
195+  6274 5E          >        ld e,(hl)
195+  6275 23          >        inc hl
195+  6276 56          >        ld d,(hl)
195+  6277 21 41 60    >        ld hl,fill_colors
195+  627A 00          >        nop ; ASSERTION DE == HL
195+  627B D1 E1       >        pop de, hl
196+  627D               TC_END
196+  627D C3 69 60    >        jp UNITTEST_TEST_READY_SUCCESS
197+  6280
198+  6280                  ENDMODULE
199+  6280
200+  6280
# file closed: unit_tests.asm
 45   6280
 46   6280
 47   6280              ;===========================================================================
 48   6280              ; main routine - the code execution starts here.
 49   6280              ; Sets up the new interrupt routine, the memory
 50   6280              ; banks and jumps to the start loop.
 51   6280              ;===========================================================================
 52   6280
 53   6280
 54   6280 00 00 00...   defs 0x8000 - $
 55   8000               ORG $8000
 56   8000
 57   8000              main:
 58   8000                  ; Disable interrupts
main.asm(59): warning: value 0x80F6 is truncated to 8bit value: 0xF6
 59   8000 3E F6        mlbl:   ld a,stack_top
 60   8002 31 F6 80     mlbl2    ld sp,stack_top
 61   8005              mlbl3:
 62   8005              mlbl4
 63   8005
 64   8005              .local
 65   8005              m.l.l:
 66   8005              .m.l.l:
 67   8005 ~            /*
 68   8005 ~                ; Switch ULA and membank
 69   8005 ~                ld bc,0x7FFD
 70   8005 ~                ;ld a,8  ; SCR = bank 7
 71   8005 ~                ld a,8+7  ; SCR = bank 7 and RAM = bank 7
 72   8005 ~                out (c),a
 73   8005 ~
 74   8005 ~                ld a,7  ; SCR = bank 5 and RAM = bank 7
 75   8005 ~                out (c),a
 76   8005 ~            */
 77   8005
 78   8005                  ; CLS
 79   8005 CD 47 60         call clear_screen
 80   8008 CD 52 60         call clear_backg
 81   800B
 82   800B                  ; Init
 83   800B              lbl1:
 84   800B 21 41 60         ld hl,fill_colors
 85   800E 22 3F 60         ld (fill_colors_ptr),hl
 86   8011 11 00 58         ld de,COLOR_SCREEN
main.asm(87): error: Label not found: ffh
 87   8014 00 FF            defb ffh, 0xff
main.asm(88): error: Label not found: ffh
 88   8016 00 FF            DEFB ffh, 0xFF
 89   8018
 90   8018                  ; Enable interrupts
 91   8018                  ;im 1
 92   8018                  ;ei
 93   8018
 94   8018              main_loop:
 95   8018                  ; fill line with color
 96   8018 2A 3F 60         ld hl,(fill_colors_ptr)
 97   801B 7E               ld a,(hl)
 98   801C CD 17 60         call fill_bckg_line1
 99   801F
100   801F                  ; break
101   801F D5               push de
102   8020 11 F4 01         ld de,PAUSE_TIME
103   8023 CD 01 60         call pause
104   8026 D1               pop de
105   8027
106   8027                  ; Alternatively wait on vertical interrupt
107   8027                  ;halt
108   8027
109   8027                  ; next line
110   8027 CD 2A 60         call inc_fill_colors_ptr
111   802A
112   802A 18 EC            jr main_loop
113   802C
114   802C
115   802C              ;===========================================================================
116   802C              ; Stack.
117   802C              ;===========================================================================
118   802C
119   802C
120   802C              ; Stack: this area is reserved for the stack
121   802C              STACK_SIZE: equ 100    ; in words
122   802C
123   802C
124   802C              ; Reserve stack space
125   802C 00 00            defw 0  ; WPMEM, 2
126   802E              stack_bottom:
127   802E 00 00 00...      defs    STACK_SIZE*2, 0
128   80F6              stack_top:
129   80F6                  ;defw 0
130   80F6 00 00            defw 0  ; WPMEM, 2
131   80F8
132   80F8
133   80F8
134   80F8                  IF NEX == 0
135   80F8                      SAVESNA "z80-sample-program.sna", main
136   80F8                  ELSE
137   80F8 ~                    SAVENEX OPEN "z80-sample-program.nex", main, stack_top
138   80F8 ~                    SAVENEX CORE 3, 1, 5
139   80F8 ~                    SAVENEX CFG 7   ; Border color
140   80F8 ~                    SAVENEX AUTO
141   80F8 ~                    SAVENEX CLOSE
142   80F8                  ENDIF
143   80F8
# file closed: main.asm
